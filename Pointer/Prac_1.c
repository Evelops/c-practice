#include <stdio.h>
/*
 * pointer prac_1  
 * pointer 란 메모리의 주소를 가르킨다. 이름만 포인터라고 장황하지 실제로는 변수랑 별 다를바가 없음. 
 * 포인터는 여러 형태로 선언될 수 있으며, prac_1에서는 포인터를 일반 변수 처럼 활용하는 법에 대해서 정리한다. 
 * 포인터변수는 일반적인 변수의 자료형과 같이 포인터 타입의 변수라고 할 수 있다. 
 * 포인터 변수는 변수의 주소값을 저장하고 있다. 
 * 포인터 변수의 크기는 모두 동일함. 동일한 OS일 경우, 주소값이 동일한 크기를 갖기 때문.
 * 하지만 자료형에 따라서 선언하는 자료형이 달라지는 이유는 가리킬 주소가 어떤 자료형을 갖는지 알려주기 위해서임. 
 * 예를들어 -> int 형이면 4byte, double -> 8byte 씩 읽어들어야함. 
 * 그렇기 때문에 가르키는 변수 -> 포인터 변수로 선언한 값이 가지는 주소가 가르키는 타입에 맞춰 자료형을 맞춰준다고 생각하면 됨.
 */


// 포인터 매개값을 가지는 함수. 
void pointerPlus(int *num)
{
    *num+=5;

}

// 일반 정수를 매개값으로 가지는 함수. 
void numPlus (int num)
{
    num+=5;
}

int main()
{
    int *p = NULL;
    int num = 15; 

    p = &num;  // num 의 주소값을 리턴.

    printf("p가 가리키는 값 : %d\n ",*p);
    printf("num값 : %d\n",num);

    *p += 5; // 포인터 p가 가리키는 주소로 가서 주소에 값을 +5 증가.
    printf("포인터 p가 가르키는 값: %d\n",*p);
    printf("num 값: %d\n",num);

    (*p)++;
    printf("포인터 p가 가르키는 값: %d\n",*p);
    printf("num 값: %d\n",num);

    *p++;
    printf("포인터 p가 가르키는 값: %d\n",*p);
    printf("num 값: %d\n",num);

    /**
     * (*p)++ vs *p++  
     * (*p)++  -> 연산의 우선순위에 따라 괄호안에 있는 p의 주소값을 찾은 후, 주소에 할당된 값에 증감연산자를 통해 +1 한 값이 출력된다. 
     * *p++    -> (*) 참조 연산보다 증감연산자가 더 우선순위가 높음. 그렇기에, 주소값이 들어있는 변수 p를 먼저 증가시키는데, 증가한 주소에 아무런 값이
     *            할당되어 있지 않기 때문에 쓰레기값 출력. 
     */

    printf("==================\n");

    int k = 20;


    numPlus(k);
    printf("numPlus 이후 k 값: %d\n",k);

    pointerPlus(&k);
    printf("pointerPlus 이후 k 값: %d",k);

    /**
     * 함수 사용시, 포인터로 메모리 주소를 넘겨주면, 함수에서 메모리에 직접적으로 참조할 수 있기 때문에
     * 위의 예시와 같이 변수 값을 바로 수정할 수 있음. 
     */



    return 0;
}